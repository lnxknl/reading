
   版本格式：主版本号.次版本号.修订号，版本号递增规则如下：

    - 主版本号：当你做了不兼容的API 修改。

    - 次版本号：当你做了向下兼容的功能性新增。

    - 修订号：当你做了向下兼容的问题修正。

让这的清楚明了是十分重要的。一旦你定义了公共API，你就可以透过修改相应的版本号来向大家说明你的修改。考虑使用这样的版本号格式：XYZ （主版本号.次版本号.修订号）修复问题但不 响API 时，递增修订号；API 保持向下兼容的新增及修改时，递增次版本号；进行不向下兼容的修改时，递增主版本号。

    - 先行版本号“可以MAY”被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符号来修饰。标识符号“必须MUST”由ASCII码的英数字和连接号[0-9A-Za-z-]组成，且“禁止M
UST   NOT”在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法达到兼容的需求。范例：1.0.0-alpha、1.0.0-alpha.1、 1.0.0-0.3.7
、1.0.0-x.7.z.92。
   举个简单的例子就可以展示语义化的版本控制如何让依赖地狱成为过去。假设有个名为“救火车”的函式库，它需要另一个名为“梯子”并已经有使用语义化版本控制的套件。当救火车创建时，
梯子但小于4.0.0。这样，当梯子版本3.1.1 和3.2.0 发布时，你可以将直接它们纳入你的套件管理系统，因为它们能与原有相依的软件兼容。

   如果你对此认同，希望立即开始使用语义化版本控制，你只需声明你的函式库正在使用它并遵循这些规则就可以了。请在你的README 文件中保留此页连结，让别人也知道这些规则并从中受益


   - 用于托管维护网站、管理网站所用资源和文档搜索增强的 Rails 应用程序

   - 用户托管由一大堆 Markdown 文件组成的网站具体内容

  我们正常的撰写流程可能是这个样子的:

   - 当有新特征开发出来的时候文档团队首先编写好文档内容

   - 创建一个新的 issue 去追踪这个特征

   - 当文档更新完毕一切就绪之后，我们会发起一个 pull request 去迭代更新文档内容。

   - PR 发起成功后，我们会使用 @ 方式提醒团队（比如 @github/docs ）并会让队友们审查一下我们的内容。

   - 当这个特征开发完毕已经上线的时候，我们会合并之前创建的 PR。 使用 webhook 能够帮助我们在 内容仓库 快速激活我们部署的 Rails应用程序。webhook 承担了负责更新数据库的任务

     ├── src
     │   ├── js
     │   │   ├── main.js
     │   │   ├── plugins.js
     │   │   └── vendor
     │   │       └── modernizr-2.8.3.min.js
     │   ├── css
     │   │   └── main.css
     │   ├── img
     │   ├── favicon.ico
     │   ├── humans.txt
     │   ├── index.html
     │   ├── 404.html
     │   ├── apple-touch-icon.png
     │   ├── browserconfig.xml
     │   ├── crossdomain.xml
     │   ├── robots.txt
     │   ├── tile-wide.png
     │   └── tile.png
     ├── test
     │   ├── file_content.js
     │   └── file_existence.js
     ├── dist
     │   ├── 404.html
     │   ├── LICENSE.txt
     │   ├── apple-touch-icon.png
     │   ├── browserconfig.xml
     │   ├── crossdomain.xml
     │   ├── css
     │   │   ├── main.css
     │   │   └── normalize.css
     │   ├── favicon.ico
     │   ├── humans.txt
     │   ├── img
     │   ├── index.html
     │   ├── js
     │   │   ├── main.js
     │   │   ├── plugins.js
     │   │   └── vendor
     │   │       ├── jquery-1.11.2.min.js
     │   │       └── modernizr-2.8.3.min.js
     │   ├── robots.txt
     │   ├── tile-wide.png
     │   └── tile.png
     ├── CHANGELOG.md
     ├── CONTRIBUTING.md
     ├── LICENSE.txt
     ├── README.md
     ├── gulpfile.js
     ├── package.json

  但是从事软件开发以及技术相关的人员，量化工作确实一个困难的事情。量化这件事情，不是在求职，更是一个技术人员生涯的一部分。绩效评估，有效的了解沟通，高效的和非技术人员合作
  ，确保你再团队或组织中的价值。

  现实世界中是怎样的呢？你试着问自己一些关键的问题：你有在更新你的代码的时候去监控和测试...这就是量化的目标。如果你在日程表前六周就完成了一个app，你肯定会去炫耀一下。但是
  你有考虑公司的战略目标吗，如果没有，请思考一下。...

                                                                           Think in percentages


                                                                  Get involved with open source projects


                                                                   Measure progress, not just products


                                                                           Keep a work journal


                                                                       Communicate in two languages


                                                                         Collect recommendations

                                                                                   常规项


   - 代码能够工作么？它有没有实现预期的功能，逻辑是否正确等。

   - 所有的代码是否简单易懂？

   - 代码符合你所遵循的编程规范么？这通常包括大括号的位置，变量名和函数名，行的长度，缩进，格式和注释。

   - 是否存在多余的或是重复的代码？

   - 代码是否尽可能的模块化了？

   - 是否有可以被替换的全局变量？

   - 是否有被注释掉的代码？

   - 循环是否设置了长度和正确的终止条件？

   - 是否有可以被库函数替代的代码？

   - 是否有可以删除的日志或调试代码？

                                                                                    安全


   - 所有的数据输入是否都进行了检查（检测正确的类型，长度，格式和范围）并且进行了编码？

   - 在哪里使用了第三方工具，返回的错误是否被捕获？

   - 输出的值是否进行了检查并且编码？

   - 无效的参数值是否能够处理？

                                                                                    文档


   - 是否有注释，并且描述了代码的意图？

   - 所有的函数都有注释吗？

   - 对非常规行为和边界情况处理是否有描述？

   - 第三方库的使用和函数是否有文档？
   - 数据结构和计量单位是否进行了解释？

   - 是否有未完成的代码？如果是的话，是不是应该移除，或者用合适的标记进行标记比如‘TODO’？

                                                                                    测试


   - 代码是否可以测试？比如，不要添加太多的或是隐藏的依赖关系，不能够初始化对象，测试框架可以使用方法等。

   - 是否存在测试，它们是否可以被理解？比如，至少达到你满意的代码覆盖(code coverage)。

   - 单元测试是否真正的测试了代码是否可以完成预期的功能？

   - 是否检查了数组的“越界“错误？

   - 是否有可以被已经存在的API所替代的测试代码？

                                                                                    总结


  你同样需要把特定语言中有可能引起错误的问题添加到清单中。

  这个清单故意没有详尽的列出所有可能会发生的错误。你不希望你的清单是这样的，太长了以至于从来没人会去用它。仅仅包含常见的问题会比较好。

  程序员能把逻辑梳理出来，是另一大技能！

  官方的格式说明，Format。必须的文件是README.md和SUMMARY.md。

                                                                                   使用方法


                                                                                   init


  gitbook init,根据SUMMARY.md生成目录。

                                                                                  build


  gitbook build，生成_books目录。

                                                                                  serve


  gitbook serve, 开启本地预览。


  一个好的程序员，不单单关注的是程序本身，还应该关注到整个团队，帮助大家协同合作，减轻自己的压力，也提高了团队的效率。

  所谓STAR原则，即Situation（情景）、Task（任务）、Action（行动）和Result（结果）四个英文单词的首字母组合。STAR原则是结构化面试当中非常重要的一个理论。

  S指的是situation,中文含义是情景，也就是在面谈中我们要求应聘者描述他在所从事岗位期间曾经做过的某件重要的且可以当作我们考评标准的事件的所发生的背景状况。

  T指的是task，中文含义为任务，即是要考察应聘者在其背景环境中所执行的任务与角色，从而考察该应聘者是否做过其描述的职位及其是否具备该岗位的相应能力。

  A指的是action,中文含义是行动，是考察应聘者在其所描述的任务当中所担任的角色是如何操作与执行任务的。

  R指的是result,中文含义为结果，即该项任务在行动后所达到的效果，通常应聘者求职材料上写的都是一些结果，描述自己做过什么，成绩怎样，比较简单和宽泛。

  而我们在面试的时候，则需要了解应聘者如何做出这样的业绩，做出这样的业绩都使用了一些什么样的方法，采取了什么样的手段，通过这些过程，我们可以全面了解该应聘者的知识、经验、
  技能的掌握程度以及他的工作风格、性格特点等与工作有关的方面。而STAR原则正是帮我们解决上述问题的。

  做一线的决策，最终成为能独当一面的人。思考发展方向，或者是谋求外部的合作机会。所以要学会彻底的放权，让团队的成员都忙起来。在可以承受的范围内让大家去犯错，去成长，去

  关于书籍的选择，技术方面还是推荐英文资料，因为翻译质量的问题。你看中文可能10分钟的内容，理解却要1小时。而英文你看需要30分钟，理解只需要10分钟。

   - stackoverflow

   - github

   - reddit:Programming

  我知道我不比许多专业科系毕业的设计学生还要优秀，但我的能力已足以将我的工作做好。我会设计许多东西，例如网页、iPhone 应用程序、电子邮件、社群媒体和印刷品等。

  高质量的睡眠能带来好的体力，这才是效率的保证。

     晚上9-11点为免疫系统（淋巴）排毒时间，此段时间应安静或听音乐
     晚间11-凌晨1点，肝的排毒，需在熟睡中进行。
     凌晨1-3点，胆的排毒，亦同。
     凌晨3-5点，肺的排毒。此即为何咳嗽的人在这段时间咳得最剧烈，
     因排毒动作已走到肺；不应用止咳药，以免抑制废积物的排除。
     凌晨5-7点，大肠的排毒，应上厕所排便。
     早上7-9点，小肠大量吸收营养的时段，应吃早餐。
     疗病者最好早吃，在6点半前，养生者在7点半前，
     不吃早餐者应改变习惯，即使拖到9、10点吃都比不吃好。
     半夜至凌晨4点为脊椎造血时段，必须熟睡，不宜熬夜。

                                                                                   提升效率


  我是个很在意效率的人，虽然可能执行力不那么强。但是能省的绝对不会浪费精力去做。

  这里的效率也包含了如何获取信息，如何与人交流，总之是对个人有益的总结。

  一个好的答案需要一个好的问题。学会提问，你会得到更多的信息。网络上有那个一篇文章:学会如何提问。我是没有读过，但是我理解它的意思。当你被别人问了几次基础或者无脑的问题，
  你就知道你希望得到的提问是什么样的。那么你其实也学会了如何提问。

  无论是否是技术人员，我觉得都应该坚持写作。写作带给你的是思维的总结，因为有些事情你只是去想，貌似是很简单。当你去深入思考，其实又是另一个境界。我觉得写作能帮助到我最大的
  一点是，理清思路。

   - 即使没人读你的文章，写作的过程也是有益无害。它帮助你理清思路，明确对于某个问题的看法，加强或削弱你的某种观点。把凌乱的想法汇聚成精简的文字非常有价值。

  对于知识，我也比较推荐"IPO"的形式，就是input->process->output。摄入的知识并不是你的收获，而只有output出来的内容才是自己的。

  我自己一般把屏幕劈成两半，左边chrome，右边iterm，这样，在vim里写代码时，随时可以查文档。配合vim的热键，我可以用 xx 在chrome里打开某个开发语言的文档，鼠标都不用动一下。

  作为一个开发者，你需要精挑细选一款趁手的用来编辑代码的editor。我使用了几年的vim，又换用过大半年的emacs，为了强制自己习惯emacs，我甚至在bash中把vim
  alias成emacs。但最终，没能打开emacs下的任督二脉的我实在无法抗拒vim下的那些好用的插件，又回到了vim的阵营。所以在editor这里，我只能先讲讲更为熟悉的vim。

  vim下最基本的vundle不提，至少这些插件你值得拥有：

   - SirVer/ultisnips: 撰写和使用snippet神器，用过textmate/sublime的人应该都知道。一个程序员的效率很大程度上跟他的snippet库有关。如果你的python class，html的标签，erlang
     honza/vim-snippets，大部分代码的snippet都有了；遇到结构类似的代码块（bolerplate），又没有已经定义好的snippet时，调用 :UltiSnipsEdit 立刻定义之，你基本上就走在无敌的
  路上了。
   - scrooloose/nerdtree：让你的vim支持文件树。这个插件加上 tpope/vim-eunuch，文件系统的各种操作和显示全在vim里搞定了。

   - sheerun/vim-polyglot：几乎所有程序语言的源文件syntax/tab等的支持。有此一个插件，就不再需要 vim-ruby，vim-go等一票单独的语言插件了。

   - Valloric/YouCompleteMe：让vim支持自动补齐。这个几乎是IDE的标配，效率提升的另一大神器。有了它，IDE的需求就减弱很多。
  一个程序员一天可能80%的时间都在跟shell打交道，有个好的shell(bash or zsh)，加上合理的shell配置绝对让效率提升一大截。我以前都是直接使用 mathiasbynens/dotfiles 的设置，后

  具，如何写代码。11年的时候我看过一个php的screencast，一个法国人介绍如何用symfony撰写项目。那是我第一次领略什么是指尖如飞，也给我播下了snippet的种子（他用的是textmate）
  。从那以后，我会时不时地看一些各种各样的screencast（以rails的居多），学习点新东西的同时，还能学习高手的习惯。

  先想想自己在当前的发展环境下发展遇阻的原因。多从自己的内因上找，不要带着抱怨情绪。不能勇于面对自己的不足，迟早还会因为自己能力不足而离开。对上一家公司的抱怨什么的不建议
  和hr说，因为你面试的下一家，以后也可能成为你的上一家。
  真正离职的理由主要是:

   - 家庭: 买了房，结了婚, 家庭开支增大，个人压力增加

   - 能力 个人能力的成长低于行业平均水平，通常说的天花板。

   - 以及公司与团队与行业相比缺少变化和生命力。

   - 一个人在同一岗位两年，胜任并已进入了舒适区，此时一般都会转岗或升职以迎接更大的挑战。

   - 价值: 当前环境中无法发挥价值，并持续一段时间，换工作属于止损。

   - 薪资: 不解释。

  我觉得在找工作的时候，认清自我是很关键的一点。不然过分的以为自己的能力超群，往往会给自己带来挫败感。

  “知己知彼，百战不殆”，我们不仅要了解自己，也还需要对外面的市场进行一下了解，比如问问其他公司的朋友，大概工作年限和水平的人待遇如何，也是为自己定价的一个方式。

  出去找工作，也以为着你要放弃现在的工作条件和人脉，到一个新的环境中成长，我们的心态也很重要。谦逊有礼会给你未来的工作之路带来好处。

   - 简历不要出现错别字和明显的错误

   - 平时的工作之余，不要忘了对自己技术的追求, 多理解多写一些代码

   - 没有不加班的IT公司，摆在心态，主要看你觉得这种加班值不值得

  一个优秀的程序员应该具有怎样的技能:

   - 基础扎实

   - 主动思考

   - 爱学习

   - 有深度

   - 有视野

   - 扎实的编码经验
