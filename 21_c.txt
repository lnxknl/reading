      根据约定，程序员在程序运行成功时返回 0，并在出现错误时返回−1。然而，返回值为整数，程序员可利用整个整数范围，指出众多不同的成功或失败状态。

      程序员为何要对自己编写的代码进行解释呢？这看起来好像有点奇怪，但程序越大，合作开发同一个模块的程序员越多，编写易于理解的代码就越重要。必须使用清晰的注释对代码的功能
以及为何要这样做进行解释，这很重要。

      函数可以接受参数，可以递归，可以包含多条返回语句，可以重载，还可声明为内联的，在这种情况下，编译器将展开函数调用。这些概念都将在第7章更详细地介绍。

      答：这是一个预处理器编译指令。预处理器在您调用编译器时运行。该指令使得预处理器将#include后面的<>中的文件读入程序，其效果如同将这个文件输入到源代码中的这个位置。

      问：什么情况下需要命令行参数？

      答：需要让用户修改程序的行为时。例如，Linux命令ls和Windows命令dir都显示当前目录（文件夹）的内容，要查看另一个目录中的文件，需要使用命令行参数指定相应的路径，如ls/或
dir\。
      • 如何使用C++11关键字auto和constexpr；

      使用汇编语言编程时，需要显式地要求处理器将被乘数存储到特定的位置，如 578，而 C++让您能够使用更友好的概念（如变量 FirstNumber）来访问内存单元，以检索和存储数据。将变
量 FirstNumber关联到内存单元的工作由编译器负责，它还负责为您完成相关的簿记工作（book Keeping）。

      使用auto——编译器的类型推断功能

      在有些情况下，根据赋给变量的初值，很容易知道其类型。例如，如果将变量的初值设置成了 true，就可推断其类型为bool。在C++11中，可不显式地指定变量的类型，而使用关键字auto

      涉及语法烦琐的复杂类型，如使用模板的类型时，typedef（类型替换）特别方便。

      因此，在 C++中，常量类似于变量，只是不能修改。与变量一样，常量也占用内存空间，并使用名称标识为其预留的空间的地址，但不能覆盖该空间的内容。在C++中，常量可以是：

      • 字面常量；

      • 使用关键字const声明的常量；

      • 使用关键字constexpr声明的常量表达式（C++11新增的）；

      • 使用关键字enum声明的枚举常量；

      • 使用#define定义的常量（已摒弃，不推荐）。
      在C++11之前，C++就支持常量表达式的概念，只是没有关键字constexpr。在程序清单3.5中， 22.0/7 是一个常量表达式，C++11 之前的编译器也支持它。然而，C++11 之前的编译器不允
许定义在编译阶段计算的函数。在C++11中，可以编写下面这样的代码：

      乍一看，const和constexpr之间的差别很小，但从编译器和应用程序的角度看，关键字Constexpy提供了优化应用程序的可能性。对于第二条语句，如果使用const，将在运行阶段执行计算
，但使用遵守C++11的编译器时，将在编译阶段计算该表达式的值，这提高了应用程序的运行速度。

      首先也是最重要的是，编写新程序时，不要使用这种常量。这里介绍使用#define定义常量，只是为了帮助您理解一些旧程序，它们使用下面的语法定义常量：
      这是一个预处理器宏，让预处理器将随后出现的所有 Pi 都替换为 3.14286。预处理器将进行文本替换，而不是智能替换。编译器既不知道也不关心常量的类型。

悉变量，下面的变量名将更好些：荐程序员不要采用匈牙利表示法。变量名必须易于理解，哪怕这会导致变量名更长些。在这个示例中，假定该布尔变量表示车前灯开关
      应不惜一切代价避免使用非描述性变量名。

      问：既然可以使用常规变量代替常量，为何还要定义常量？

      答：通过声明常量（尤其是使用关键字const时），可告诉编译器，其值是固定的，不允许修改。这样，编译器将确保不给常量赋值，即便另一位程序员接手了您的工作，不小心试图覆盖
常量的值。因此，在知道变量的值不应改变时，应将其声明为常量，这是一个不错的编程习惯，可提高应用程序的质量。

      有时候，需要根据变量的值（通常是核实它不为零）做条件处理，如果不对变量进行初始化，这样的逻辑将不可靠，因为未赋值或初始化的变量包含的内容是随机的。

      问：为何不应频繁地使用全局变量？全局变量在应用程序的任何地方都可用，可避免在函数之间传递值，从而节省一些时间，这种说法对吗？

      答：可在应用程序的任何地方读取全局变量的值以及给它赋值，这是个问题，因为在应用程序的任何地方都可修改它们。假设您与其他几位程序员合作开发一个项目，并将变量声明为全局
的。如红皂白地使用全局变量。修改这些变量——即便是在另一个.CPP文件中，都将影响代码的可靠性。因此，为确保代码的稳定性，不要为节省几秒钟甚至几分钟而不分青

      这不是 unsigned short的问题，而是使用它的方式有问题；在变量的取值可能为负时，就不应将其类型指定为 unsigned int、unsigned short或 unsigned long。如果MyShortInt被用于
指定动的内存！更糟糕的是，如果在访问内存单元是将MyShortInt用作索引，很可能访问外部内存单元，进而导致应用程序崩溃！

      采用这种方式时，如果用户希望这个程序存储并显示500个整数，您将需要声明500个int变量。只要有足够的耐心和时间，这还是可行的。然而，如果用户要求存储并显示500000个整数，
您该怎么办呢？

      这样的数组被称为静态数组，因为在编译阶段，它们包含的元素数以及占用的内存量都是固定的。

      被要求访问索引为N的元素时，编译器以第一个元素（索引为零）的内存地址为起点，加上偏移量N*sizeof(element)，即向前跳N个元素，到达包含第N+1个元素的地址。C++编译器不会检
查索引组时，确保不超越其边界是程序员的职责。素的数组中取回索引为1001的元素，但这样做将给程序带来安全和稳定性方面的风险。访问数


      虽然C++让您能够模拟多维数组，但存储数组的内存是一维的。编译器将多维数组映射到内存，而内存只沿一个方向延伸。如果您愿意，也可像下面这样初始化数组SolarPanelIDs，其效果
相同：

      程序清单6.14演示了一种更高效的多维数组访问方式，它使用嵌套for循环来访问多维数组中的所有元素。使用 for 循环时，代码更短且不容易出错；另外，程序长度也不受数组包含的元
素数的影响。

      为减少占用的内存，可不使用前面介绍的静态数组，而使用动态数组，并在运行阶段根据需要增大动态数组。C++提供了 std::vector，这是一种方便且易于使用的动态数组，如程序清单

      请注意，该数组的最后一个字符为空字符‘\0’。这也被称为字符串结束字符，因为它告诉编译器，字符串到此结束。这种C风格字符串是特殊的字符数组，因为总是在最后一个字符后加上
空字符‘\0’。您在代码中使用字符串字面量时，编译器将负责在它后面添加‘\0’。
      在数组中间插入‘\0’并不会改变数组的长度，而只会导致将该数组作为输入的字符串处理将到这个位置结束，程序清单4.5演示了这一点。

      ‘\0’看起来像两个字符。使用键盘输入它时，确实需要输入两个字符，但反斜杆是编译器能够理解的特殊转义编码，\0表示空，即它让编译器插入空字符或零。

      第 10行将“Hello World”中的空格替换为终止空字符。这样，该数组包含两个终止空字符，但只有第一个发挥了作用。将空格替换为空字符后，显示时字符串被截短为Hello。第7和12行的
sizeof()的输出表明，数组的长度没变，虽然显示的字符串发生了很大变化。

      输出说明了这种危险。该程序请求用户输入数据时不要超过20个字符，因为第7行声明了一个字符数组，用于存储用户输入，其长度是固定的（静态的），为 21 个字符。由于最后一个字
符必须符串末尾的终止空字符，并计算遍历的字符数。cin在用户输入的末尾插入终止空字符。strlen的这种行为非常危险，因为如果用户输入的文本长度超过了指定的上限， strlen将跨越字符
数组的边界。程序清单6.2演示了如何实现相关的检查，以免写入数组时跨越其边界。

      使用C语言编写的应用程序经常使用strcpy 等字符串复制函数、strcat等拼接函数，还经常使用strlen来确定字符串的长度；具有较强C语言背景的C++程序员编写的应用程序亦如此。

      这些C风格字符串作为输入的函数非常危险，因为它们会寻找终止空字符，如果程序员没有在字符数组末尾添加空字符，这些函数将跨越字符数组的边界。

      C++提供了 std::string，这是一种功能强大而安全的字符串操作方式，如程序清单 4.7 所示。不同于字符数组（C风格字符串实现），std::string是动态的，在需要存储更多数据时其容
量将增大。

            问：为何要不怕麻烦，去初始化静态数组的元素？

            答：数组不同于其他类型的变量，除非进行初始化，否则它将包含无法预测的值，因为内存保留最后一次操作时的内容。通过初始化数组，可确保内存包含确定的值。

            问：需要基于前一个问题所说的原因初始化动态数组的元素吗？

            答：实际上，不需要。动态数组相当聪明，无需将其元素初始化为默认值，除非应用程序要求数组包含特定的初始值。

            问：在可以选择的情况下，您会使用需要以空字符结尾的C风格字符串吗？

            答：除非有人拿枪指着您的头。C++ std::string更安全，并提供了很多功能，任何优秀的程序员都应避免使用C风格字符串。

            编译器通常不考虑空白，这包括空格、制表符、换行符、回车等，但字符串字面量中的空格将导致输出不同。

            5.3.2 理解左值和右值

            左值通常是内存单元。在前面的示例中，变量MyInteger实际上指向一个内存单元，属于左值。另一方面，右值可以是内存单元的内容。


            首先需要理解前缀和后缀之间的差别，这样才能选择合适的方式。使用后缀运算符时，先将右值赋给左值，再将右值递增或递减。这意味着在上述所有使用后缀运算符的代码中，Nu
m2 都为 Num1的旧值（执行递增或递减前的值）。
            前缀运算符的行为完全相反，即先将右值递增或递减，再将结果赋给左值。在所有使用后缀运算符的代码中，Num2的值都与Num1的值相同。程序清单5.2演示了将前缀和后缀递增和
递减运算符用于一个int变量的结果。
            因此，所有的左值都可用作右值，但并非所有的右值都可用作左值。为更好地理解这一点，请看下面的示例，这行代码不合理，不能通过编译：

            您经常会听到前缀运算符的性能更高还是后缀运算符更高的争论。换句话说，++MyInt优于MyInt++。

            至少从理论上说确实如此，因为使用后缀运算符时，编译器需要临时存储初始值，以防需要将其赋给其他变量。就整型变量而言，这对性能的影响几乎可以忽略不计，但对某些类来
说，这种争论也许有意义。

            就拿unsigned short来说吧，它占用16位内存，因此取值范围为0～65535。usigned short变量的值为65535后，如果再加1，将导致溢出，结果为0。这很像汽车的里程表，如果它只
支持5位数字，则里程超过99999公里（或英里）后，里程表将发生机械溢出。
            在这种情况下，将计数器的变量类型指定为unsigned short不合适。要支持大于65535的数字，程序员应使用数据类型unsigned int。

            数据类型 signed short的取值范围为−32768～32768，如果这种变量的值已经是 32768，则将其加 1的结果为最小的负数——这取决于编译器。

            移位运算符将整个位序列向左或向右移动，其用途之一是将数据乘以或除以2^{n}。

            sizeof(…)看起来像函数调用，但它并不是函数，而是运算符。有趣的是，程序员不能定义这个运算符，因此不能重载它。

            您可能在学校学过算术运算顺序口诀BODMAS（Brackets Orders Division Multiplication Addition Subtraction，先括号，后乘除，再加减），它指出了复杂算术表达式的计算顺

            这里声明了一个名为JumpToPoint的标签，并使用goto跳转到这个地方，如程序清单6.7所示。除非给goto语句指定在特定情况下将为false的执行条件，或者重复执行的代码中包含
在特定条件下将被执行的return语句，否则goto命令和标签之间的代码将无休止地执行下去，导致程序永不结束。

            while、do…while和for 循环都包含一个条件表达式，循环在它为false时结束。如果您指定的条件总是为true，循环就不会结束。

            程序清单6.12 使用continue进入下一次循环，并使用break退出无限for循环

            在程序清单6.12中，使用了空语句for(;;)来创建无限循环。您也可以使用其他类型的循环来生成相同的输出，为此可将该语句替换为while(true)或do…while(true);。

            到目前为止，本书的示例程序都使用 main()实现所有功能。对小型应用程序来说，这完全可行，但随着程序越来越大、越来越复杂，除非使用函数，否则main()将越来越长。

            函数让您能够划分和组织程序的执行逻辑。通过使用函数，可将应用程序的内容划分成依次调用的逻辑块。

            函数原型指出了函数的名称（Area）、函数接受的参数列表（一个名为InputRadius的double参数）以及返回值的类型（double）。

            如果函数声明中包含形参（parameter），调用函数时必须提供实参（argument），它们是函数的形参列表要求的值。下面来分析程序清单7.1中对函数Area的调用：

            程序清单7.4演示了如何编写参数包含默认值的函数，这种默认值可被用户提供的值覆盖。

            可以给多个参数指定默认值，但这些参数必须位于参数列表的末尾。

            在有些情况下，可让函数调用它自己，这样的函数称为递归函数。递归函数必须有明确的退出条件，满足这种条件后，函数将返回，而不再调用自己。
            如果没有退出条件或存在 bug，递归函数可能不断调用自己，直到栈溢出后才停止，导致应用程序崩溃。

            并非只能每次给函数传递一个值，还可将数组传递给函数。您可创建两个名称和返回类型相同，但参数不同的函数。您可创建这样的函数，即其参数不是在函数内部创建和销毁的；
为此可使用在数。退出后还可用的引用，这样可在函数中操纵更多数据或参数。在本节中，您将学习将数组传递给函数、函数重载以及按引用给函数传递参

            第一个参数告诉函数，输入的数据是一个数组，而第二个参数指出了数组的长度，以免您使用数组时跨越边界，如程序清单7.8所示。

            这意味着函数调用不会影响main()中的变量Radius，因为Area()使用的是Radius包含的值的拷贝。有时候，您可能希望函数修改的变量在其外部（如调用函数）中也可用，为此，可
将形参的类型声明为引用。下面的Area()函数计算面积，并以参数的方式按引用返回它：

            使用return语句时，函数只能返回一个值。因此，如果函数需要执行影响众多值的操作，且需要在调用者中使用这些值，则按引用传递参数是让函数将修改结果提供给调用模块的方
式之一。

            栈是一种后进先出的内存结构，很像堆叠在一起的盘子，您从顶部取盘子，这个盘子是最后堆叠上去的。将数据加入栈被称为压入操作；从栈中取出数据被称为弹出操作。栈增大时
，栈指针将不断递增，始终指向栈顶，如图7.3所示。

            栈的性质使其非常适合用于处理函数调用。函数被调用时，所有局部变量都在栈中实例化，即被压入栈中。函数执行完毕时，这些局部变量都从栈中弹出，栈指针返回到原来的地方

            常规函数调用被转换为CALL指令，这会导致栈操作、微处理器跳转到函数处执行等。听起来在幕后发生了很多事情，但在大多数情况下速度都很快。然而，如果函数非常简单，类似
于下面这样又如何呢？

            相对于实际执行GetPi()所需的时间，执行函数调用的开销可能非常高。这就是C++编译器允许程序员将这样的函数声明为内联的原因。程序员使用关键字 inline 发出请求，要求在
函数被调用时就地展开它们：

            将函数声明为内联的会导致代码急剧膨胀，在声明为内联的函数做了大量复杂处理时尤其如此。应尽可能少用关键字 inline，仅当函数非常简单，需要降低其开销时（如前面所示
），才应使用该关键字。

            大多数较新的C++编译器都提供了各种性能优化选项。有些提供了优化大小或速度的选项，如Microsoft C++编译器。为内存弥足金贵的设备和外设开发软件时，优化代码的大小至关
重要。优化代码大小时，编译器可能拒绝众多的内联请求，因为这会让代码急剧膨胀。
            优化速度时，编译器通常会寻找并利用合理的内联机会，为您完成内联工作，即便您没有显式地请求这样做。

            如果您在编程时经常使用STL算法对包含在STL容器（如std::vector）中的数据进行排序或处理，lambda
            函数将很有用。通常，排序算法要求您提供一个二元谓词（它被实现为类中的一个运算符），这导致编码工作非常烦琐。遵守C++11标准的编译器让您能够编写lambda函数，从而极
大地简化代码，如程序清单7.11所示。
            第15～19行将几个整数压入到一个动态数组中，这个动态数组是使用C++标准模板库中的std::vector表示的。函数DisplayNums使用STL算法遍历数组的每个元素，并显示其值。为此
，它在第8行使lambda函数的方式提供了一个二元谓词（第26行），这个函数在第二个数比第一个数小时返回true，这相当于将集合按升序排列。

            C++最大的优点之一是，您既可使用它来编写不依赖于机器的高级应用程序，又可使用它来编写与硬件紧密协作的应用程序。事实上，C++让您能够在字节和比特级调整应用程序的性
能。要编写高效地利用系统资源的程序，理解指针和引用是必不可少的一步。

            因此，指针是一个变量，与所有变量一样，指针也占用内存空间（在图8.1中，其地址为0x101）。指针的特殊之处在于，指针包含的值（这里为 0x558）被解读为内存地址，因此指
针是一种指向内存单元的特殊变量。

            作为一种变量，指针也需要声明。通常将指针声明为指向特定的类型，如int，这意味着指针包含的地址对应的内存单元存储了一个整数。也可将指针声明为指向一个内存块，这种
指针被称为void指针。

            与您学过的所有数据类型一样，除非对指针进行初始化，否则它包含的将是垃圾值。对指针来说，这种垃圾值非常危险，因为指针包含的值被视为地址。未初始化的指针可能导致程
序访问非法内存单元，进而导致程序崩溃。

            在您的输出中，地址可能不同。事实上，即使在同一台计算机上，每次运行该应用程序时输出的变量地址都可能不同。

            8.1.4 使用解除引用运算符（*）访问指向的数据

            有了包含合法地址的指针后，如何访问这个地方，即如何获取或设置这个地方的数据呢？答案是使用解除引用运算符（*）。基本上，如果有合法的指针pData，要访问它包含的地址
处存储的值，可使用*pData。程序清单8.4演示了这种运算符（*）。

            将解除引用运算符（*）用于该指针时，应用程序从它存储的地址开始，取回内存中4个字节的内容（因为该指针指向的是int变量，而sizeof(int)为4），因此指针包含的地址必须
合法。第11行引用通常会导致非法访问（Access Violation），即访问应用程序未获得授权的内存单元。含随机值，此时对其解除

            8.1.5 将sizeof()用于指针的结果

            您知道，指针是包含内存地址的变量。因此无论指针指向哪种类型的变量，其内容都是一个地址——一个数字。在特定的系统中，存储地址所需的字节数是固定的。因此，将sizeof()
用于指针时，结果取决于编译程序时使用的编译器和针对的操作系统，与指针指向的变量类型无关，程序清单8.6演示了这一点。

            程序清单8.6的输出表明，将sizeof用于指针的结果为4字节，但在您的系统上结果可能不同。这里的输出是使用32位编译器编译代码时得到的，如果您使用的是64位编译器，并在64
位系统上运行该程序，可能发现将sizeof用于指针的结果为64位，即8字节。

            程序将存在下面两个问题。

            1．这限制了程序的容量，无法存储100个以上的数字。

            2．如果只需存储1个数字，却为100个数字预留存储空间，这将降低系统的性能。

            导致这些问题的原因是，数组的内存分配是静态和固定的。

            要编写根据用户需要使用内存资源的应用程序，需要使用动态内存分配。这让您能够根据需要分配更多内存，并释放多余的内存。为帮助您更好地管理应用程序占用的内存，C++提
供了两个运算符——new和delete。指针是包含内存地址的变量，在高效地动态分配内存方面扮演了重要角色。

            您使用new来分配新的内存块。通常情况下，如果成功，new将返回指向一个指针，指向分配的内存，否则将引发异常。使用new时，需要指定要为哪种数据类型分配内存：

            new 表示请求分配内存，并不能保证分配请求总能得到满足，因为这取决于系统的状态以及内存资源的可用性。

            使用new分配的内存最终都需使用对应的delete进行释放：

            不再使用分配的内存后，如果不释放它们，这些内存仍被预留并分配给您的应用程序。这将减少可供其他应用程序使用的系统内存量，甚至降低您的应用程序的执行速度。这被称为
内存泄露，应不惜一切代价避免这种情况发生。
            不能将运算符delete用于任何包含地址的指针，而只能用于new返回的且未使用delete释放的指针。

            其中最重要的代码行是第14和23行，它们分别使用了运算符new[…]和delete[]。相比于程序清单8.7，这个程序清单的不同之处在于，为多个元素而不是单个元素分配内存块。对于
为一系列元素行计算需要为多少个字符分配内存时，将用户输入的字符数加1，以便能够存储对C风格字符串来说至关重要的终止空字符。第4章解释了为何需要终止空字符。实际的复制工作是在
第 17行使用 c_str()得到的结果作为输入，将其复制到char缓冲区CopyOfName中。

            运算符new和delete分配和释放自由存储区中的内存。自由存储区是一种内存抽象，表现为一个内存池，应用程序可分配（预留）和释放其中的内存。

            指针包含内存地址。例如，程序清单8.3的int指针包含0x002EFB34——int在内存中的地址。int本身长4字节，因此占用0x002EFB34-0x002EFB37的内存。将递增运算符用于该指针后，
它指向的并不是0x002EFB35，因为指向int中间毫无意义。
            如果您对指针执行递增或递减运算，编译器将认为您要指向内存块中相邻的值（并假定这个值的类型与前一个值相同），而不是相邻的字节（除非值的长度刚好是1字节，如char）
            则执行++pType后，pType将包含（指向）Address + sizeof(Type)。

            第3章介绍过，通过将变量声明为const的，可确保变量的取值在整个生命周期内都固定为初始值。这种变量的值不能修改，因此不能将其用作左值。

            指针也是变量，因此也可将关键字const用于指针。然而，指针是特殊的变量，包含内存地址，还可用于修改内存中的数据块。因此，const指针有如下三种。

            • 指针指向的数据为常量，不能修改，但可以修改指针包含的地址，即指针可以指向其他地方。
            • 指针包含的地址是常量，不能修改，但可修改指针指向的数据。
            • 指针包含的地址以及它指向的值都是常量，不能修改（这种组合最严格）。
            将指针传递给函数时，这些形式的const很有用。函数参数应声明为最严格的const指针，以确保函数不会修改指针指向的值。这让函数更容易维护，在时过境迁和人员更迭后尤其如
此指针方式传入10所示。算圆的面积，就不应允许它修改半径。为控制函数可修改哪些参数以及不能修改哪些参数，可使用const指针，如程序清单8.。

            编译器将分配固定数量的内存，用于存储 5 个整数；同时向您提供一个指向数组中第一个元素的指针，而指针由您指定的数组名标识。换句话说， MyNumbers 是一个指针，指向第
一个元素（MyNumber[0]），程序清单8.11演示了这种关系。
            要访问第二个元素，可使用MyNumbers[1]，也可通过指针pNumbers来访问，其语法为*(pNumbers+1)。要访问静态数组的第三个元素，可使用MyNumbers[2]，而要访问动态数组的第
三个元素，可使用语法*(pNumbers+2)。
            由于数组变量就是指针，因此也可将用于指针的解除引用运算符（*）用于数组。同样，可将数组运算符（[]）用于指针，如程序清单8.12所示。
            在这个应用程序中，第8行声明并初始化了一个包含5个int元素的静态数组。这个应用程序通过两种可相互替换的方式显示该数组的内容，一种是使用数组变量和间接运算符（*），
如第15行所示；另一种方式是使用指针变量和数组运算符（[]），如第19行所示。
            该程序表明，数组MyNumbers和指针pNumbers都具有指针的特点。换句话说，数组类似于在固定内存范围内发挥作用的指针。可将数组赋给指针，如第11行所示，但不能将指针赋给
数组，因为数组是静态的，不能用作左值。
            使用运算符new动态分配的指针仍需使用运算符delete来释放，虽然其使用语法与静态数组类似。牢记这一点很重要。

            如果忘记这样做，应用程序将泄露内存，这很糟糕。

            C++让您能够动态地分配内存，以优化应用程序对内存的使用。不同于C#和Java等基于运行时环境的新语言，C++没有自动垃圾收集器对程序已分配但不能使用的内存进行清理。指针
使用起来比较棘手，程序员很容易犯错。
            这可能是 C++应用程序最常见的问题之一：运行时间越长，占用的内存越多，系统越慢。如果在使用new动态分配的内存不再需要后，程序员没有使用配套的delete释放，通常就会
出现这种情况。
            确保应用程序释放其分配的所有内存是程序员的职责。绝不能让下面这样的情形发生：

            使用运算符*对指针解除引用，以访问指向的值时，务必确保指针指向了有效的内存单元，否则程序要么崩溃，要么行为不端。这看起来合乎逻辑，但一个非常常见的导致应用程序
崩溃的原因就是无效指针。指针无效的原因很多，但都要归结于糟糕的内存管理。程序清单8.13演示了一种导致指针无效的典型情形。
            同样，第22行对这个指针调用delete，但并未使用new分配这个指针，这也是大错特错。如果有指针的多个拷贝，只需对其中一个调用delete（应避免指针拷贝满天飞）。
            要让程序清单8.13所示的程序更好、更安全、更稳定，应对指针进行初始化，确定指针有效后再使用并只释放指针一次（且仅当指针有效时才释放）。
            主要差别在于，需要时（即用户按y时）才创建指针，并在创建时对其进行初始化，如第12行所示。在同一个代码块中释放了内存，避免了在没有赋给指针有效内存地址的情况下使
用它（解除引用或调用delete）。

            除非请求分配的内存量特大，或系统处于临界状态，可供使用的内存很少，new 一般都能成功。有些应用程序需要请求分配大块的内存（如数据库应用程序），一般而言，不要假定
内存分配能够loc异常。这导致应用程序中断执行，除非您提供了异常处理程序，否则应用程序将崩溃，并显示一条类似于“异常未处理”的消息。
            这个程序与程序清单 8.15 相同，但使用的是 new(nothrow)，这样分配内存失败时，将返回NULL，而不是引发异常std::bad_alloc。这两种做法都可行，如何选择取决于您。
            输出表明，无论将引用初始化为变量（如第9行所示）还是其他引用（如第12行所示），它都指向相应变量所在的内存单元。因此，引用是真正的别名，即相应变量的另一个名字。
            上述代码导致将argument的值复制给Parameter，再被函数DoSomething()使用。如果argument占用了大量内存，这个复制步骤的开销将很大。同样，当
            DoSomething()返回值时，这个值被复制给Result。如果能避免这些复制步骤，让函数直接使用调用者栈中的数据就太好了。为此，可使用引用。
            8.5.2 将关键字const用于引用

            可能需要禁止通过引用修改它指向的变量的值，为此可在声明引用时使用关键字const：
                8.3.3 悬浮指针（也叫迷途或失控指针）

                使用delete释放后，任何有效指针都将无效。因此，在程序清单8.13中，即便用户按了y，在第22行前指针pTemperature是有效的，但第22行调用delete后，它也变成无效的了
，不应再使用。
                为避免这种问题，很多程序员在初始化指针或释放指针后将其设置为NULL，并在使用运算符*对指针解除引用前检查它是否有效。
                为释放内存，是否需要对它们都调用delete？

                答：这样做是错误的。对new返回的地址，只能调用delete一次。另外，最好避免让两个指针指向相同的地址，因为对其中一个调用 delete 将导致另一个无效。另外，编写程
序时，应避免使用有效性不确定的指针。

                至此，您探索了简单程序的结构。这种程序从 main()开始执行，让您能够声明局部和全局变量和常量、将执行逻辑划分为可接受参数和返回值的函数。这与C语言等过程型语言
很像，不涉及面向对象。换句话说，您需要学习如何管理数据并将其与方法关联起来。
                在本章中，您将学习：

                • 什么是类；

                • 类如何帮助您整合数据和处理数据的方法（类似于函数）；

                • 构造函数、复制构造函数和析构函数；

                • C++11如何通过移动构造函数改进性能；

                • 封装和抽象等面向对象的概念；

                • this指针；

                • 结构是什么，它与类有何不同。
                要模拟人，需要一个结构，将定义人的属性（数据）以及人可使用这些属性执行的操作（类似于函数的方法）整合在一起。这种结构就是类。
                封装指的是将数据以及使用它们的方法进行逻辑编组，这是面向对象编程的重要特征。
                类相当于蓝图，仅声明类并不会对程序的执行产生影响。在运行阶段，对象是类的化身。要使用类的功能，通常需要根据类实例化一个对象，并通过对象访问成员方法和属性。
                如果有一个指针pTom，它指向Human类的一个实例，则可使用指针运算符（->）来访问成员（这将在下一小节介绍），也可使用间接运算符（*）来获取对象，再使用句点运算符
来访问成员：
                C++让您能够将类属性和方法声明为公有的，这意味着有了对象后就可获取它们；也可将其声明为私有的，这意味着只能在类的内部（或其友元）中访问。作为类的设计者，您
可使用 C++关键字public和private来指定哪些部分可从外部（如main()）访问，哪些部分不能。
                将出现类似于这样的编译错误：“错误：Human::Age——不能访问Human类声明的私有成员”。要访问Age，唯一的途径就是通过Human类的公有方法GetAge()，这个方法以编写Human
类的程序员认为的合适方式暴露Age：
                要设置年龄，唯一的途径是通过SetAge()：
                这有很多优点。当前，SetAge()的实现只是直接设置成员变量 Human::Age，但也可在 SetAge()中验证外部输入，避免Age被设置为零或负数：
                总之，C++让类的设计者能够控制类属性的访问和操纵方式。
                在面向对象编程语言中，抽象是一个非常重要的概念，让程序员能够决定哪些属性只能让类及其成员知道，类外的任何人都不能访问（友元除外）。
                ::被称为作用域解析运算符。例如，Human::DateOfBirth指的是在Human类中声明的变量DateOfBirth，而::DateOfBirth表示全局作用域中的变量DateOfBirth。
                构造函数总是在创建对象时被调用，这让构造函数是将类成员变量（int、指针等）初始化为已知值的理想场所。再看一下程序清单9.2。如果忘记调用SetAge()，int变量Human
::Age将包含未知的好的Human类版本，它使用构造函数初始化Age。30行注释掉）。程序清单9.3是一个更
                可在不提供参数的情况下调用的构造函数被称为默认构造函数。默认构造函数是可选的。如果您像程序清单 9.1 那样没有提供默认构造函数，编译器将为您创建一个，这种构
造函数会创建成员属性，但不会初始化POD类型（如int）的属性。
                初始化列表由包含在括号中的参数声明后面的冒号标识，冒号后面列出了各个成员变量及其初始值。初始值可以是参数（如InputName），也可以是固定的值。使用特定参数调
用基类的构造函数时，初始化列表也很有用，这将在第10章讨论。
                每当对象不再在作用域内或通过 delete 被删除，进而被销毁时，都将调用析构函数。这使得析构函数是重置变量以及释放动态分配的内存和其他资源的理想场所。
                析构函数不能重载，每个类都只能有一个析构函数。如果您忘记了实现析构函数，编译器将创建一个伪（dummy）析构函数并调用它。伪析构函数为空，即不释放动态分配的内
存。
                二进制复制并不深复制指向的内存单元，这导致两个 MyString
                对象指向同一个内存单元。函数UseMyString()返回时，变量Input不再在作用域内，因此被销毁。为此，将调用MyString类的析构函数，而该析构函数使用delete释放分配给Bu
ffer的内存（如程SayHello 指向的内存无效，而等 main()执行完毕时，SayHello 将不再在作用域内，进而被销毁。然而，第26行对不再有效的内存地址调用
                delete（销毁Input时释放了该内存，导致它无效）。图9.2的调试断言消息指出错误出在第52行（本书的行号从零开始，因此是第51行），因为未能成功地销毁这里创建的对象
SayHello。

                                                                                  [IMAGE]

                在这里，编译器没有进行深复制，因为编译时它不确定指针成员MyString::Buffer指向的是多少字节的内存。

                程序清单9.9 的输出表明，拷贝中的 Buffer 指向内存地址不同，即两个对象并未指向同一个动态分配的内存地址。因此，函数 UseMyString()返回、形参 Input
                被销毁时，析构函数对复制构造函数分配的内存地址调用delete[]，而没有影响main()中SayHello指向的内存。因此，这两个函数都执行完毕时，成功地销毁了各自的对象，没
有导致应用程序崩溃。

                由于您没有指定任何赋值运算符，编译器提供的默认赋值运算符将导致浅复制。为避免赋值时进行浅复制，您需要实现复制赋值运算符（=）。
                通过在复制构造函数声明中使用const，可确保复制构造函数不会修改指向的源对象。另外，复制构造函数的参数必须按引用传递，否则调用它时将复制实参的值，导致对源数
据进行浅复制——这正是您要极力避免的。
                正如注释指出的，实例化sayHelloAgain时，由于调用了函数Copy(sayHello)，而它按值返回一个MyString，因此调用了复制构造函数两次。然而，这个返回的值存在时间很短
，且在该表达式外很大的动态对象数组，对性能的影响将很大。函数反而降低了性能，如果复制的是

                为避免这种性能瓶颈，除编写复制构造函数，还应编写一个移动构造函数。移动构造函数的语法如下：

                移动构造函数通常是利用移动赋值运算符实现的，这将在第12章更详细地讨论。程序清单12.12是一个更好的MyString版本，实现了移动构造函数和移动赋值运算符。

                本章介绍了几个重要的基本概念，如构造函数、析构函数以及使用关键字public和private等抽象数据和方法。等您设计类时，这些概念让您能够控制其对象的创建、复制和销
毁方式，还可控制其数据的暴露方式。

                显然，需要避免这样的情况发生。编写操作系统时，您需要模拟一个局域网、一个处理器等，为此需要避免这样的资源被复制。如果您不声明复制构造函数，C++将为您添加一
个公有的默认复制构造函数，这破坏了您的设计，威胁着您的实现。然而，C++提供了实现这种设计范式的解决方案。
                要禁止类对象被复制，可声明一个私有的复制构造函数。这确保函数调用DoSomething(OurPresident)无法通过编译。为禁止赋值，可声明一个私有的赋值运算符。

                前面讨论的President类很不错，但存在一个缺陷：无法禁止通过实例化多个对象来创建多名总统：
                将关键字static用于类的数据成员时，该数据成员将在所有实例之间共享。

                将static用于函数中声明的局部变量时，该变量的值将在两次调用之间保持不变。

                将static用于成员函数（方法）时，该方法将在所有成员之间共享。

                要创建单例类，关键字static必不可少，如程序清单9.10所示。

                第47和48行分别试图使用默认构造函数在堆和栈上创建对象，但默认构造函数不可用，因为它是私有的，如第8行所示。

                第49行试图使用复制构造函数创建现有对象的拷贝（在创建对象的同时为其赋值，将调用复制构造函数），但在main()中不能使用复制构造函数，因为第11行将其声明成了私有
的。

                例如，如果应用程序从模拟一个国家升级到模拟联合国（当前，联合国有192位成员，因此有192位总统），单例模式将是个架构问题。

                9.6.3 禁止在栈中实例化的类

                栈空间通常有限。如果您要编写一个数据库类，其内部结构包含1GB数据，可能应该禁止在栈上实例化它，而只允许在堆上创建其实例。为此，关键在于将析构函数声明为私有
的：

                上述代码将导致内存泄露。由于在main中不能调用析构函数，因此也不能调用delete。为解决这种问题，需要在MonsterDB类中提供一个销毁实例的静态公有函数（作为类成员
，它能够调用析构函数），如程序清单9.11所示。
                程序清单9.11 数据库类MonsterDB，只能使用new在自由存储区中创建其对象

                这些代码旨在演示如何创建禁止在栈中实例化的类。为此，将构造函数声明成了私有的，如第 6行所示。另外，它还包含静态函数DestroyInstance()，如第9～13行所示；在ma
in()中，第28行调用了该静态函数。

                   9.7 this指针

                在C++中，一个重要的概念是保留的关键字this。在类中，关键字this包含当前对象的地址，换句话说，其值为&object。当您在类成员方法中调用其他成员方法时，编译器将隐
式地传递this指针——函数调用中不可见的参数：

                您知道，通过使用关键字class声明自定义类型，可封装数据属性和使用数据的方法。第3章介绍过，运算符 sizeof()用于确定指定类型需要多少内存（单位为字节）。这个运
算符也可用于类，些属性进行填充，使其与字边界对齐，也可能不这样做，这取决于您使用的编译器。用于类时，sizeof()不考虑成员函数及其定义的局部变量，如程序清单9.12所示。

                首先来分析输出。从中可知，将 sizeof()用于类及其对象时，结果相同。sizeof(MyString)和sizeof(FirstMan)的值相同，因为类占用的字节数在编译阶段就已确定，且在设
计时就知道。虽然占用的字节数相同，这没什么可奇怪的，因为存储姓名的MyString::Buffer是一个 char *，这是一个大小固定的指针（在我使用的 32位系统中，为 4字节），而与指向的数据
量无关。

                将sizeof()用于Human时，结果为12。第53～55行表明，Human 包含一个int 成员、一个 bool成员和一个MyString成员。要获悉内置类型占用的字节数，请参阅程序清单3.4。
从该程序清单可知int占用4字节，bool占用1字节，而MyString占用4字节。它们的总和与输出中的12字节不符，这是因为 sizeof()的结果受字填充（word padding）和其他因素的影响。

                关键字struct来自C语言，在C++编译器看来，它与类及其相似，差别在于程序员未指定时，默认的访问限定符（public 和
                private）不同。因此，除非指定了，否则结构中的成员默认为公有的（而类成员默认为私有的）；另外，除非指定了，否则结构以公有方式继承基结构（而类为私有继承）。
继承将在第10章详细讨论。

                不能从外部访问类的私有数据成员和方法，但这条规则不适用于友元类和友元函数。要声明友元类或友元函数，可使用关键字friend，如程序清单9.13所示。

                这种缺陷显然应该避免。您需要让基类的某些属性能在派生类中访问，但不能在继承层次结构外部访问。这意味着您希望Fish类的布尔标记FreshWaterFish可在派生类Tuna和Ca
rp中访问，但不能。实例化Tuna和Carp的main()中访问。为此，可使用关键字protected

                与public和private一样，protected也是一个访问限定符。将属性声明为protected时，相当于允许派生类和友元类访问它，但禁止在继承层次结构外部（包括main()）访问它

                如果基类包含重载的构造函数，需要在实例化时给它提供实参，该怎么办呢？创建派生对象时将如何实例化这样的基类？方法是使用初始化列表，并通过派生类的构造函数调用
合适的基类构造函数，如下面的代码所示：

                在程序清单10.4中，派生类Tuna通过实现Swim()覆盖了Fish类的Swim()函数，其结果如下：


                                                                                  [IMAGE]


                在程序清单10.4中，如果要在main()中调用Fish::Swim()，需要使用作用域解析运算符（::），如下所示：

                前面介绍的都是公有继承，私有继承的不同之处在于，指定派生类的基类时使用关键字private：

                私有继承意味着在派生类的实例中，基类的所有公有成员和方法都是私有的——不能从外部访问。换句话说，即便是 Base 类的公有成员和方法，也只能被 Derived 类使用，而
无法通过 Derived实例来使用它们。

                因此，从继承层次结构外部看，私有继承并非 is-a 关系。私有继承使得只有子类才能使用基类的属性和方法，因此也被称为has-a关系。在现实世界中，存在一些私有继承的
例子，如表10.2所示。

                如果有一个SuperCar类，它继承了Car类，则不管SuperCar和Car之间的继承关系是什么样的，SuperCar都不能访问基类Motor的公有成员和方法。这是因为Car和Motor之间是私
有继承关系，这意，编译器在确定派生类能否访问基类的公有或保护成员时，考虑的是继承层次结构中最严格的访问限定符。

                保护继承与私有继承的类似之处如下：

                • 它也表示has-a关系；

                • 它也让派生类能够访问基类的所有公有和保护成员；

                • 在继承层次结构外面，也不能通过派生类实例访问基类的公有成员。

                随着继承层次结构的加深，保护继承将与私有继承有些不同：


                                                                                  [IMAGE]


                在保护继承层次结构中，子类的子类（即Derived2）能够访问Base类的公有成员，如程序清单10.9所示。如果Derived和Base之间的继承关系是私有的，就不能这样做。

                仅当必要时才使用私有或保护继承。

                对于大多数使用私有继承的情形（如Car和Motor之间的私有继承），更好的选择是，将基类对象作为派生类的一个成员属性。通过继承Motor类，相当于对Car类进行了限制，使
其只能有一台发动车除电力发动机外，还有一台汽油发动机。在这种情况下，让Car类继承Motor类将成为兼容性瓶颈。

                它们都将Derived对象复制给Base对象，一个是通过显式复制，另一个是通过传递参数。在这些情形下，编译器将只复制objectDerived的Base部分，即不是整个对象，而是Base
能容纳的部分，这称为切除（slicing）。这种无意间裁减数据，导致Derived变成Base的行为

                要避免切除问题，不要按值传递参数，而应以指向基类的指针或const引用的方式传递。

                本章前面说过，在有些情况下，采用多继承是合适的，如对鸭嘴兽来说就很合适，这是因为鸭嘴兽具备哺乳动物、鸟类和爬行动物的特征。为应对这样的情形，C++允许继承多

                理想情况下，用户希望 Tuna 对象表现出金枪鱼的行为，即便通过 Fish 参数调用 Swim()时亦如此。换句话说，第25行调用InputFish.Swim()时，用户希望执行的是Tuna::Swi
m()。要实现这种多Tuna）的行为，可将 Fish::Swim()声明为虚函数。

                通过使用关键字virtual，可确保编译器调用覆盖版本。也就是说，如果Swim()被声明为虚函数，则将参数myFish（其类型为Fish&）设置为一个Tuna对象时，myFish.Swim()将
执行Tuna::Swim()，如程序清单11.2所示。

                这就是多态：将派生类对象视为基类对象，并执行派生类的Swim()实现。

                这个程序清单表明，对于使用new在自由存储区中实例化的派生类对象，如果将其赋给基类指针，并通过该指针调用delete，将不会调用派生类的析构函数。这可能导致资源未
释放、内存泄露等问题，必须引起重视。
                要避免这种问题，可将析构函数声明为虚函数，如程序清单11.4所示。
                程序清单11.4 将析构函数声明为虚函数，确保通过基类指针调用delete时，将调用派生类的析构函数

                相比于程序清单11.3，程序清单11.4唯一不同的地方是，在第10行声明基类Fish的析构函数时，添加了关键字virtual。这种修改导致将运算符delete用于Fish指针（如第31行
所示）时，如果该行Tuna::~Tuna()。输出还表明，无论Tuna对象是使用new在自由存储区中实例化的（第37行），还是以局部变量的方式在栈中实例化的，构造函数和析构函数的调用顺序都相同

                每个虚函数表都由函数指针组成，其中每个指针都指向相应虚函数的实现。在类Derived的虚函数表中，除一个函数指针外，其他所有函数指针都指向 Derived 本地的虚函数实
现。Derived 没有覆盖Base::Func2()，因此相应的函数指针指向Base类的Func2()实现。
                这意味着遇到下述代码时，编译器将查找Derived类的VFT，确保调用Base::Func2()的实现：
                程序清单11.5将sizeof用于两个相同的类（一个包含虚函数，另一个不包含），并对结果进行比较，从而证明了确实存在隐藏的虚函数表指针。

                最大程度地简化了这个示例。其中有两个类——SimpleClass和Base，它们包含的成员数量和类型都相同，但在Base中，将FuncDoSomething()声明成了虚函数，而在SimpleClass
中没有这样做。添个虚函数表，并其虚函数表指针（一个隐藏成员）预留空间。在32位系统中，Base类占用的内存空间多了4字节，这证明确实存在这样的指针。

                这被称为运行阶段类型识别（Run Time Type Identification，RTTI）。虽然大多数C++编译器都支持RTTI，但应尽可能避免这样做。因为需要知道基类指针指向的是派生类对
象通常是一种糟糕的编程实践。

                AbstractBase类要求Derived类必须提供虚方法DoSomething()的实现。这让基类可指定派生类中方法的名称和特征（Signature），即指定派生类的接口。再次以Tuna类为例，
假定它继承了Fish实现存在缺陷。通过将Swim声明为纯虚函数，让Fish变成抽象基类，可确保从Fish派生而来的Tuna类实现Tuna::Swim()，从而像金枪鱼那样游动，如程序清单11.6所示。

                输出表明，由于采用了多继承，且 Platypus 的全部三个基类都是从 Animal
                类派生而来的，因此第38行创建Platypus实例时，自动创建了三个Animal实例。这太可笑了，因为鸭嘴兽是一种动物，继承了哺乳动物、鸟类和爬行动物的属性。存在多个Anim
al实例带来的问题有一个整型成员——Animal::Age，为方便说明问题，将其声明成了公有的。如果您试图通过Platypus 实例访问 Animal::Age（如第 42
                行所示），将导致编译错误，因为编译器不知道您要设置Mammal::Animal::Age、Bird::Animal::Age还是Reptile::Animal::Age。更可笑的是，如果您愿意，可以分别设置这三
个属性：

                在继承层次结构中，继承多个从同一个类派生而来的基类时，如果这些基类没有采用虚继承，将导致二义性。这种二义性被称为菱形问题（Diamond Problem）。

                其中的“菱形”可能源自类图的形状（如果使用直线和斜线表示Platypus经由Mammal、Bird和Reptile与Animal建立的关系，将形成一个菱形）。

                在函数声明中，virtual意味着当基类指针指向派生对象时，通过它可调用派生类的相应函数。从Base类派生出Derived1和Derived2类时，如果使用了关键字virtual，则意味着
再从Derived1和De含一个Base实例。也就是说，关键字virtual被用于实现两个不同的概念。
                根本不可能实现虚复制构造函数，因为在基类方法声明中使用关键字virtual时，表示它将被派生类的实现覆盖，这种多态行为是在运行阶段实现的。而构造函数只能创建固定
类型的对象，不具备多态性，因此C++不允许使用虚复制构造函数。

                虚函数Clone模拟了虚复制构造函数，但需要显式地调用，如程序清单11.9所示。

                在main()中，第 40～44行声明了一个静态基类指针（Fish *）数组，并各个元素分别设置为新创建的Tuna、Carp、Tuna和Carp对象。注意到myFishes数组能够存储不同类型的
对象，这些对象都同类型的数据，如int。如果这还不够酷，您还可以在循环中使用虚函数Fish::Clone将其复制到另一个Fish*数组（myNewFishes）中，如第48行所示。注意到这里的数组很小，
只有4个元素，但即行进行了核实，它通过新数组的每个元素调用虚函数 Swim()，以验证Clone()复制了整个派生类对象，而不仅仅是Fish部分。输出表明，确实像预期的那样复制了整个派生类 象。

   从语法层面看，除使用关键字 operator 外，运算符与函数几乎没有差别。运算符声明看起来与函数声明极其相似：

   在上述后缀运算符的实现中，首先复制了当前对象，再将对当前对象执行递增或递减运算，最后返回复制的对象。

   与普通指针相比，除能够在指针离开作用域后释放其占用的内存外，智能指针还有很多其他功能，这将在第26章详细讨论。

   从上述代码可知，相比于常规赋值构造函数和复制赋值运算符的声明，移动构造函数和移动赋值运算符的不同之处在于，输入参数的类型为MyClass&&。另外，由于输入参数是要移动的源对象
，因此不能使用const进行限定，因为它将被修改。返回类型没有变，因为它们分别是构造函数和赋值运算符的重载版本。
   在需要创建临时右值时，遵循 C++的编译器将使用移动构造函数（而不是复制构造函数）和移动赋值运算符（而不是复制赋值运算符）。移动构造函数和移动赋值运算符的实现中，只是将资
源从源移到目的地，而没有进行复制。程序清单12.12演示了如何使用这两项C++11新增功能对MyString类进行优化。
   程序清单 12.12 除复制构造函数和复制赋值运算符外，还包含移动构造函数和移动赋值运算符的MyString类

   4个C++类型转换运算符如下：

   • static_cast

   • dynamic_cast

   • reinterpret_cast

   • const_cast

   其中pDerived实际上指向一个不完整的Derived对象，因为它指向的对象实际上是Base()类型。由于 static_cast 只在编译阶段检查转换类型是否相关，而不执行运行阶段检查，因此 pDeriv
ed->SomeDerivedClassFunction()能够通过编译，但在运行阶段可能导致意外结果。
   除用于向上转换和向下转换外，static_cast还可在很多情况下将隐式类型转换为显式类型，以引起程序员或代码阅读人员的注意：

   如上述代码所示，给定一个指向基类对象的指针，程序员可使用 dynamic_cast 进行类型转换，并在使用指针前检查指针指向的目标对象的类型。在上述示例代码中，目标对象的类型显然是D
eridynamic_cast 判断基类指针指向的对象的类型，再执行该类型特有的操作。总之，可使用dynamic_cast在运行阶段判断类型，并在安全时使用转换后的指针。程序清单13.1使用了一个您熟悉
的继Tuna和Carp类从基类Fish派生而来，其中的函数DetectFishtype()动态的检查Fish指针指向的对象是否是Tuna或Carp。

   reinterpret_cast是C++中与C风格类型转换最接近的类型转换运算符。它让程序员能够将一种对象类型转换为另一种，不管它们是否相关；也就是说，它使用如下所示的语法强制重新解释类
型：

   应尽量避免在应用程序中使用 reinterpret_cast，因为它让编译器将类型 X 视为不相关的类型Y，这看起来不像是优秀的设计或实现。

   除非万不得已，否则不要使用const_cast来调用非const函数。一般而言，使用const_cast来修改const对象可能导致不可预料的行为。

   宏也进行文本替换。预处理器只是就地将标识符替换为指定的文本。

   这样的输出显然不符合逻辑，而最重要的是，编译器却没有检测到这一点。另外，对于使用宏定义的常量PI，您没有太大的控制权：其类型是double还是float？答案是都不是。在预处理器看
来，PI就是3.1416，根本不知道其数据类型。
   定义常量时，更好的选择是使用关键字const和数据类型，因此下面的定义好得多：
   14.2.1 使用宏避免多次包含

   C++程序员通常在.h文件（头文件）中声明类和函数，并在.cpp文件中定义函数，因此需要在.cpp文件中使用预处理器编译指令#include <header>来包含头文件。如果在头文件
   class1.h中声明了一个类，而这个类将class2.h中声明的类作为其成员，则需要在class1.h中包含class2.h。如果设计非常复杂，即第二个类需要第一个类，则在class2.h中也需要包含class
1.h！
   然而，在预处理器看来，两个头文件彼此包含对方会导致递归问题。为避免这种问题，可结合使用宏以及预处理器编译指令#ifndef和#endif。

   宏函数通常用于执行非常简单的计算。相比于常规函数调用，宏函数的优点在于，它们将在编译前就地展开，因此在有些情况下有助于改善代码的性能。程序清单 14.2 演示了如何使用这些
   宏不考虑数据类型，因此使用宏函数很危险。例如，理想情况下，AREA_CIRCLE的返回类型应为double，这样可确保返回的圆面积的精度，使其不依赖于半径的精度。

   在省略了括号的情况下，简单的文本替换破坏了编程逻辑！使用括号有助于避免这种问题：
   通过使用括号，让宏代码不受运算符优先级的影响，从而能够正确地计算面积。

   在Microsoft Visual Studio中，assert()让您能够单击“重试”按钮返回应用程序，而调用栈将指出哪行代码没有通过断言测试。这让assert()成为一项方便的调试功能；例如，可使用assert
对函数的输入参数进行验证。长期而言，assert有助于改善代码的质量，强烈推荐使用它。

   在大多数开发环境中，assert()通常在发布模式下被禁用，因此它仅在调试模式下显示错误消息。

   如果MIN()为常规函数，必须编写两个不同的版本：MIN_INT()和MIN_DOUBLE()，前者接受int参数并返回一个int值，而后者接受double参数并返回一个double值。使用宏函数减少了代码行，
这是为函数调用要求创建调用栈、传递参数等，这些开销占用的CPU时间通常比MIN执行的计算还多。单宏的性能由于常规函数调用。这是因

   虽然具备这些优点，宏也存在严重的问题，那就是不支持任何形式的类型安全。另外，复杂的宏调试起来也不容易。

   如果需要编写独立于类型的泛型函数，又要确保类型安全，可使用模板函数，而不是宏函数。如果要改善性能，可将函数声明为内联的。

   模板可能是C++语言中最强大却最少被使用（或被理解）的特性之一。
   在 C++中，模板让程序员能够定义一种适用于不同类型的对象的行为。这听起来有点像宏（参见前面用于判断两个数中哪个更大的简单宏MAX），但宏不是类型安全的，而模板是类型安全的。

   关键字 template标志着模板声明的开始，接下来是模板参数列表。该参数列表包含关键字typename，它定义了模板参数objectType，objectType是一个占位符，针对对象实例化模板时，将使
用对象的类型替换它。
   模板声明可以是：

   • 函数的声明或定义；

   • 类的定义或声明；

   • 类模板的成员函数或成员类的声明或定义；

   • 类模板的静态数据成员的定义；

   • 嵌套在类模板中的类的静态数据成员的定义；

   • 类或类模板的成员模板的定义。

   然而，调用模板函数时没有必要这样做。您无需指定模板参数的类型，因为编译器能够自动推断出类型；但使用模板类时，需要这样做。

   第9章介绍过，类是一种编程单元，封装类属性以及使用这些属性的方法。属性通常是私有成员，如Human类中的 int Age。类是设计蓝图，其实际表示为对象。例如，可将Tom视为Human类的
一个long变量来存储其年龄，而对于寿命较短的人，则使用short变量来存储其年龄，该如何办呢？此时模板类可派生用场。模板类是模板化的 C++类，是蓝图的蓝图。使用模板类时，可指定要 哪种int成员中，还有的存储在short成员中。uman对象，即有的年龄存储在 long long成员中，有的存储在

   前面说过，模板是用于创建类的蓝图，而类是用于创建对象的蓝图。在模板类中，静态成员属性的工作原理是什么样的呢？第 9 章介绍过，如果将类成员声明为静态的，该成员将由类的所有
实例包含静态成员X，该成员将在针对int具体化的所有实例之间共享；同样，它还将在针对double具体化的所有实例之间共享，且与针对int具体化的实例无关。换句话说，可以认为编译器创建 两个版本的X：X_int用于针对int具体化的实例，而X_double针对double具体化的实例，程序清单14.5演示了这一点。

   也就是说，对于针对每种类型具体化的类，编译器确保其静态变量不受其他类的影响。模板类的每个具体化都有自己的静态成员。

   static_assert是C++11新增的一项功能，让您能够在不满足指定条件时禁止编译。这好像不可思议，但对模板类来说很有用。您可能想禁止针对int实例化模板类，为此可使用static_assert
，它是一种编译阶段断言，可用于在开发环境（或控制台中）显示一条自定义消息：
   要禁止针对类型int实例化模板类，可使用static_assert()，并将sizeof(T)与sizeof(int)进行比较，如果它们相等，就显示一条错误消息：

   模板最重要也是最强大的应用是在标准模板库（STL）中。STL 由一系列模板类和函数组成，它们分别包含泛型实用类和算法。这些STL模板类让您能够实现动态数组、链表以及包含键-值对的
容器，而sort等算法可用于这些容器，从而对容器包含的数据进行处理。
